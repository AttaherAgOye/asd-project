================================================================================
           QUESTIONS THÉORIQUES POTENTIELLES - CONTRÔLE PRATIQUE
================================================================================

============================================================
1. QUESTIONS SUR LES COMPLEXITÉS
============================================================

Q: Quelle est la complexité de la construction du R-quadtree ?
R: O(n) où n = nombre de pixels. On parcourt chaque pixel une fois.

Q: Quelle est la complexité de compressLambda ?
R: O(m) où m = nombre de nœuds. On parcourt chaque nœud une seule fois
   en post-ordre (récursion puis traitement).

Q: Quelle est la complexité de compressPhi ?
R: O(m × k) où m = nombre de nœuds et k = nombre de fusions nécessaires.
   À chaque itération, on parcourt tous les nœuds pour trouver le meilleur
   candidat à fusionner.

Q: Pourquoi utilise-t-on un AVL plutôt qu'une liste ?
R: L'AVL garantit O(log n) pour recherche/insertion/suppression.
   Une liste aurait O(n) pour la recherche.

Q: Quelle est la complexité de la recherche dans l'AVL ?
R: O(log n) car l'arbre est équilibré (hauteur = log n).

Q: Quelle est la complexité de l'insertion dans l'AVL ?
R: O(log n) = O(log n) pour descendre + O(1) pour rééquilibrer
   (au plus 2 rotations).

Q: Quelle est la complexité de toPNG() ?
R: O(n) où n = nombre de pixels. On remplit chaque pixel une fois.

Q: Quelle est la complexité de toStr() pour le R-quadtree ?
R: O(m) où m = nombre de nœuds. On parcourt chaque nœud une fois.


============================================================
2. QUESTIONS SUR LA STRUCTURE DU R-QUADTREE
============================================================

Q: Qu'est-ce qu'un R-quadtree ?
R: Un arbre quaternaire où chaque nœud interne a exactement 4 fils
   (NO, NE, SE, SO) représentant les 4 quadrants d'une région.
   Les feuilles stockent la couleur d'une région homogène.

Q: Comment fonctionne la "compression naturelle" ?
R: Lors de la construction, si les 4 fils d'un nœud sont des feuilles
   de même couleur, on fusionne en une seule feuille.

Q: Expliquez la différence entre Lambda et Phi.
R: Lambda : contrôle la QUALITÉ (dégradation max de luminance autorisée)
   Phi : contrôle le POIDS (nombre max de feuilles autorisées)

Q: Comment calcule-t-on la luminance ?
R: L = 0.2126×R + 0.7152×G + 0.0722×B (avec R,G,B normalisés entre 0 et 1)

Q: Pourquoi utilise-t-on la luminance plutôt que les couleurs RGB ?
R: La luminance représente la perception humaine de la luminosité.
   Elle permet de comparer des couleurs de façon perceptuelle.


============================================================
3. QUESTIONS SUR L'AVL
============================================================

Q: Qu'est-ce qu'un AVL ?
R: Un arbre binaire de recherche équilibré où la différence de hauteur
   entre les sous-arbres gauche et droit est au plus 1 pour tout nœud.

Q: Quel est le facteur d'équilibre ?
R: balance = hauteur(gauche) - hauteur(droite)
   Doit être dans {-1, 0, 1} pour un AVL valide.

Q: Quand fait-on une rotation simple à droite ?
R: Quand balance > 1 ET balance(gauche) >= 0
   (déséquilibre gauche-gauche)

Q: Quand fait-on une rotation simple à gauche ?
R: Quand balance < -1 ET balance(droite) <= 0
   (déséquilibre droite-droite)

Q: Quand fait-on une double rotation gauche-droite ?
R: Quand balance > 1 ET balance(gauche) < 0
   (déséquilibre gauche-droite)

Q: Quand fait-on une double rotation droite-gauche ?
R: Quand balance < -1 ET balance(droite) > 0
   (déséquilibre droite-gauche)

Q: Quel ordre utilise-t-on pour comparer les couleurs ?
R: Ordre lexicographique RGB : d'abord R, puis G si égalité, puis B.


============================================================
4. QUESTIONS SUR L'IMPLÉMENTATION
============================================================

Q: Pourquoi utilise-t-on ArrayList et pas HashMap ?
R: Le sujet interdit TreeSet, HashMap, HashSet. Seuls ArrayList et
   LinkedList sont autorisés.

Q: Pourquoi ne modifie-t-on pas ImagePNG.java ?
R: C'est un fichier fourni. Le sujet dit de ne pas le modifier.

Q: Comment représente-t-on les couleurs ?
R: Par un code hexadécimal à 6 caractères (RRGGBB).
   Exemple : "ff0000" = rouge, "00ff00" = vert, "0000ff" = bleu.

Q: Quel format utilise toStr() pour le R-quadtree ?
R: Format parenthésé hiérarchique : (fils1 fils2 fils3 fils4)
   Exemple : (ffffff (000000 ffffff ffffff ffffff) 7f7f7f ffffff)

Q: Quel format utilise toStr() pour l'AVL ?
R: Parcours infixe avec chaque code entre parenthèses.
   Exemple : (000000) (7f7f7f) (ffffff)


============================================================
5. QUESTIONS DE DÉBOGAGE / CORRECTION DE CODE
============================================================

Q: Ce code est-il correct ? Pourquoi ?

    private int countLeaves(Node node) {
        if (node.isLeaf()) return 1;
        return countLeaves(node.NO) + countLeaves(node.NE);
    }

R: Non ! Il manque :
   1. La vérification node == null
   2. Les appels pour node.SE et node.SO


Q: Trouvez l'erreur :

    public void compressLambda(double lambda) {
        if (node.isLeaf()) return;
        mergeNode(node);  // Toujours fusionner
        compressLambda(node.NO);
        compressLambda(node.NE);
        compressLambda(node.SE);
        compressLambda(node.SO);
    }

R: Erreurs :
   1. On fusionne AVANT de vérifier les fils
   2. On fusionne TOUJOURS sans vérifier le seuil lambda
   3. L'ordre devrait être : récursion d'abord, puis vérification, puis fusion


============================================================
6. EXERCICES DE MODIFICATION DE CODE
============================================================

Exercice type 1 : "Ajoutez une méthode getHeight() qui retourne
                   la hauteur du quadtree"

Exercice type 2 : "Modifiez toStr() pour afficher aussi la taille
                   de chaque région"

Exercice type 3 : "Ajoutez une méthode toGrayscale() qui convertit
                   l'image en niveaux de gris"

Exercice type 4 : "Ajoutez une méthode getMin() dans l'AVL qui retourne
                   la plus petite couleur"

Exercice type 5 : "Ajoutez une méthode mirrorHorizontal() qui fait
                   un miroir de l'image"


============================================================
7. CONSEILS POUR L'EXAMEN
============================================================

1. TOUJOURS vérifier node == null en début de récursion
2. TOUJOURS penser à l'ordre du parcours (préfixe, infixe, suffixe)
3. Pour les AVL : penser au rééquilibrage après modification
4. Bien commenter la complexité des méthodes
5. Utiliser les méthodes existantes (colorToHex, hexToColor, etc.)
6. Ne pas utiliser de structures interdites (HashMap, TreeSet...)

================================================================================
